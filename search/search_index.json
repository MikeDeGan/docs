{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Test link to an image end of image test","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#test-link-to-an-image","text":"","title":"Test link to an image"},{"location":"#end-of-image-test","text":"","title":"end of image test"},{"location":"Dates and Times/","text":"Dates and Times Here's a thing: Should check out the Moment library https://momentjs.com/","title":"Dates and Times"},{"location":"Dates and Times/#dates-and-times","text":"Here's a thing: Should check out the Moment library https://momentjs.com/","title":"Dates and Times"},{"location":"ReactRouter/","text":"React Router Programmatic Navigation //programmatic navigation back to the root route // sometimes a little tricky import history from \"../history\"; history.push(\"/\"); // import createHistory from \"history/createBrowserHistory\"; const createHistory = require(\"history\").createBrowserHistory; export default createHistory(); Switch React Router will, by default, route 'greedily' That just means that if multiple routes match it will try to go to both routes. As in this it would go to streams/new and to streams/:id when you just want /streams/new <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> To stop this behavior and have it stop after the first hit you need to add the Switch component from react router dom as... import { Router, Route, Switch } from \"react-router-dom\"; <Switch> <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> </Switch>","title":"React Router"},{"location":"ReactRouter/#react-router","text":"","title":"React Router"},{"location":"ReactRouter/#programmatic-navigation","text":"//programmatic navigation back to the root route // sometimes a little tricky import history from \"../history\"; history.push(\"/\"); // import createHistory from \"history/createBrowserHistory\"; const createHistory = require(\"history\").createBrowserHistory; export default createHistory();","title":"Programmatic Navigation"},{"location":"ReactRouter/#switch","text":"React Router will, by default, route 'greedily' That just means that if multiple routes match it will try to go to both routes. As in this it would go to streams/new and to streams/:id when you just want /streams/new <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> To stop this behavior and have it stop after the first hit you need to add the Switch component from react router dom as... import { Router, Route, Switch } from \"react-router-dom\"; <Switch> <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> </Switch>","title":"Switch"},{"location":"SSH/","text":"SSH SSH (secure shell) is just another protocol like http, ftp, etc. SSH allows us to share files and control computers over the Internet in an encrypted form. On Linux or Apple just use the ssh command, if on Windows use Putty. Example, to log in to one of the Raspberry Pis and login as the user 'pi' use this command: ssh 192.168.1.126 -l pi or ssh pi@192.168.1.126 Techniques used in SSH Symmetrical Encryption Symmetrical encryption uses a single key to encrypt and to decrypt. The key is never shared, publicly or privately. It uses a 'key exchange' using asymmetrical encryption. Asymmetrical Encryption Asymmetrical encryption is only used by ssh to exchange the shared key. This is known as the Difiie Hellman Key Exchange. The symmetrical encrypted key that gets used by ssh gets generated by this 'key exchange'. Each end, the client and the host, will generate a public/private key pair. They will then trade their public keys. Then using the other ends public key and their private key they will each generate an identical 'shared key.' The cool part is that the shared key is never shared, it is never sent over the internet or sent anywhere. Each end, client and host, are able to generate the key using their private key and the other ends public key. So it is very difficult for a man in the middle to ever get the key. So this seems very secure so far. However, a person could potentially still sit in the middle and send iits own public keys to both the client and the host and generate shared keys with each. As the host sends something the man in the middle will decrypt it then encrypt it using the clients key and so on. This is where hashing comes in. Hashing A hash gets created using the secret key, the packet sequence number and the message contents. One end sends the hash, the other end will try to generate a hash using the same inputs and if the hashes match that pretty much ensures that the sender is using the same secret key. RSA To gen an rsa public/private key pair with Linux: cd ~ cd .ssh ssh-keygen -t rsa -b 2048 The -t is for 'type', the -b if for bytes. It will ask you for a keyname and a passphrase. SSH on Github","title":"SSH"},{"location":"SSH/#ssh","text":"SSH (secure shell) is just another protocol like http, ftp, etc. SSH allows us to share files and control computers over the Internet in an encrypted form. On Linux or Apple just use the ssh command, if on Windows use Putty. Example, to log in to one of the Raspberry Pis and login as the user 'pi' use this command: ssh 192.168.1.126 -l pi or ssh pi@192.168.1.126","title":"SSH"},{"location":"SSH/#techniques-used-in-ssh","text":"","title":"Techniques used in SSH"},{"location":"SSH/#symmetrical-encryption","text":"Symmetrical encryption uses a single key to encrypt and to decrypt. The key is never shared, publicly or privately. It uses a 'key exchange' using asymmetrical encryption.","title":"Symmetrical Encryption"},{"location":"SSH/#asymmetrical-encryption","text":"Asymmetrical encryption is only used by ssh to exchange the shared key. This is known as the Difiie Hellman Key Exchange. The symmetrical encrypted key that gets used by ssh gets generated by this 'key exchange'. Each end, the client and the host, will generate a public/private key pair. They will then trade their public keys. Then using the other ends public key and their private key they will each generate an identical 'shared key.' The cool part is that the shared key is never shared, it is never sent over the internet or sent anywhere. Each end, client and host, are able to generate the key using their private key and the other ends public key. So it is very difficult for a man in the middle to ever get the key. So this seems very secure so far. However, a person could potentially still sit in the middle and send iits own public keys to both the client and the host and generate shared keys with each. As the host sends something the man in the middle will decrypt it then encrypt it using the clients key and so on. This is where hashing comes in.","title":"Asymmetrical Encryption"},{"location":"SSH/#hashing","text":"A hash gets created using the secret key, the packet sequence number and the message contents. One end sends the hash, the other end will try to generate a hash using the same inputs and if the hashes match that pretty much ensures that the sender is using the same secret key.","title":"Hashing"},{"location":"SSH/#rsa","text":"To gen an rsa public/private key pair with Linux: cd ~ cd .ssh ssh-keygen -t rsa -b 2048 The -t is for 'type', the -b if for bytes. It will ask you for a keyname and a passphrase.","title":"RSA"},{"location":"SSH/#ssh-on-github","text":"","title":"SSH on Github"},{"location":"TyporaTest/","text":"Typora that is a huge margin. kljfljfljsldfkjsdlf lskjdfls lskjd fl lskdjf l lkjsdf ll lksdjf lll sdflkl lskdjf ll sdlfkj llsjd fllksjdf llksdjf lskdjf lksdjf llskdj flslskdjf lslskjd fpwuerp wriu wsdjf lsz,mnvcnv ,xnv ,xc There must be a better way to insert images! This is a quick bit of code: class GoogleAuth extends React.Component { componentDidMount() { window.gapi.load(\"client:auth2\", () => { window.gapi.client .init({ clientId: \"318802615607-3l2k61n5spk3n7u6b2mb49geeqi2ueng.apps.googleusercontent.com\", scope: \"email\" }) .then(() => { this.auth = window.gapi.auth2.getAuthInstance(); this.onAuthChange(this.auth.isSignedIn.get()); this.auth.isSignedIn.listen(this.onAuthChange); }); }); } Have some tasks to do... [ ] do this [x] and this [ ] not this Now what ?","title":"TyporaTest"},{"location":"TyporaTest/#there-must-be-a-better-way-to-insert-images","text":"This is a quick bit of code: class GoogleAuth extends React.Component { componentDidMount() { window.gapi.load(\"client:auth2\", () => { window.gapi.client .init({ clientId: \"318802615607-3l2k61n5spk3n7u6b2mb49geeqi2ueng.apps.googleusercontent.com\", scope: \"email\" }) .then(() => { this.auth = window.gapi.auth2.getAuthInstance(); this.onAuthChange(this.auth.isSignedIn.get()); this.auth.isSignedIn.listen(this.onAuthChange); }); }); } Have some tasks to do... [ ] do this [x] and this [ ] not this Now what ?","title":"There must be a better way to insert images!"},{"location":"React/Hooks/","text":"Hooks Why Hooks Hooks overcomes many of the issues that we come across when using class based components. Calling Super(props) is annoying Classes make knowing how 'this' works difficult at times Organizing components by life-cycle methods forces us to sprinkle related logic throughout our components. React has no good primitive for sharing non-visual logic. Just use Functions Using functions instead of classes removes the Super(props) and 'this' issues right away. Ok great now what about state and life-cycle methods, they are kind of handy. State No need for a class based component. You will need to import 'useState' into your functional component. import React, { useState } from 'react' const Shop = props => { const [cart, setCart] = useState([]) const cartHandler = () => { setCart(['A Book']) } return <button onClick={cartHandler}>Add to Cart</button> } useState() returns an array with two elements. The first element is the state and the second is a function that will set the state. State is not just one object containing everything. You can have several 'states' and they can be anything like a string or boolean, whatever. It does not have to be an array as shown above. If you have multiple pieces if state that you need to track just create them like this... const [cart, setCart] = useState([]) const [myList, setMyList] = useState('not an array') When you set state it will completely replace state. You don't just pass in updates as you did in a class based component. So if your state was set to {el1: 'one', el2: 'two'} you could not just do setState({el2: 'three'}) you would have to either do setState({...state}, {el2: 'three'}) or something similar. Lifecycle Methods It looks like lifecycle Methods are sort of being referred to as 'side effects' under React Hooks. The core React Hook that will be used in place of the Lifecycle Methods is called useEffect(). componentDidMount To perform the functionality of the class based componentDidMount do the following import React, { useState, useEffect } from 'react' const Shop = props => { const [products, setProducts] = useState([]) useEffect(() => { fetch('my-backend.com/products') .then(res => res.json()) .then(fetchedProducts => setProducts(fetchedProducts)) }, []) return ( <ul> {products.map(product => ( <li key={product.id}>{product.name}</li> ))} </ul> ) } The key here is the second element of the useEffect function, the empty array []. The second element controls when this function gets run. It will run whenever the second element changes. So setting the second element to an empty array will ensure that it will never change and never run again.","title":"Hooks"},{"location":"React/Hooks/#hooks","text":"","title":"Hooks"},{"location":"React/Hooks/#why-hooks","text":"Hooks overcomes many of the issues that we come across when using class based components. Calling Super(props) is annoying Classes make knowing how 'this' works difficult at times Organizing components by life-cycle methods forces us to sprinkle related logic throughout our components. React has no good primitive for sharing non-visual logic.","title":"Why Hooks"},{"location":"React/Hooks/#just-use-functions","text":"Using functions instead of classes removes the Super(props) and 'this' issues right away. Ok great now what about state and life-cycle methods, they are kind of handy.","title":"Just use Functions"},{"location":"React/Hooks/#state","text":"No need for a class based component. You will need to import 'useState' into your functional component. import React, { useState } from 'react' const Shop = props => { const [cart, setCart] = useState([]) const cartHandler = () => { setCart(['A Book']) } return <button onClick={cartHandler}>Add to Cart</button> } useState() returns an array with two elements. The first element is the state and the second is a function that will set the state. State is not just one object containing everything. You can have several 'states' and they can be anything like a string or boolean, whatever. It does not have to be an array as shown above. If you have multiple pieces if state that you need to track just create them like this... const [cart, setCart] = useState([]) const [myList, setMyList] = useState('not an array') When you set state it will completely replace state. You don't just pass in updates as you did in a class based component. So if your state was set to {el1: 'one', el2: 'two'} you could not just do setState({el2: 'three'}) you would have to either do setState({...state}, {el2: 'three'}) or something similar.","title":"State"},{"location":"React/Hooks/#lifecycle-methods","text":"It looks like lifecycle Methods are sort of being referred to as 'side effects' under React Hooks. The core React Hook that will be used in place of the Lifecycle Methods is called useEffect().","title":"Lifecycle Methods"},{"location":"React/Hooks/#componentdidmount","text":"To perform the functionality of the class based componentDidMount do the following import React, { useState, useEffect } from 'react' const Shop = props => { const [products, setProducts] = useState([]) useEffect(() => { fetch('my-backend.com/products') .then(res => res.json()) .then(fetchedProducts => setProducts(fetchedProducts)) }, []) return ( <ul> {products.map(product => ( <li key={product.id}>{product.name}</li> ))} </ul> ) } The key here is the second element of the useEffect function, the empty array []. The second element controls when this function gets run. It will run whenever the second element changes. So setting the second element to an empty array will ensure that it will never change and never run again.","title":"componentDidMount"},{"location":"React/Portals/","text":"Modal window in a React app The key to getting a modal window to work in React is to use Portals. Portals allow a component to render a sub component but to have it act as a child of some other component, usually the 'root' div. In this example StreamDelete is opening a modal window under 'root'. Portals are described in detail in the Udemy course Modern React with Redux section 21. When you attach the modal to a div the modal will replace the content of that div or whatever with the content of your modal. So you will almost always create a sibling to the 'root' element to attach the modal to. <body> <noscript>You need to enable JavaScript to run this app.</noscript> <div id=\"root\"></div> <div id=\"modal\"></div> </body> The modal component will not return normal jsx it will return the ReactDOM.createPortal function. import React from \"react\"; import ReactDOM from \"react-dom\"; const Modal = props => { return ReactDOM.createPortal( <div className=\"ui dimmer modals visible active\"> <div className=\"ui standard modal visible active\"> lorem20 crap lkjsflj ljsdf ljf lkjs flksjdf </div> </div>, document.querySelector(\"#modal\") ); }; export default Modal; To call the modal you just call it like any component import React from \"react\"; import Modal from \"../Modal\"; const StreamDelete = () => { return ( <div> StreamDelete <Modal /> </div> ); }; export default StreamDelete; NOTE: You would normally use Portals to render modal windows but would also use portals if trying to render some React component into some html that was not created by your application like server side rendered html like Java or Ruby or something like that.","title":"Portals"},{"location":"React/Portals/#modal-window-in-a-react-app","text":"The key to getting a modal window to work in React is to use Portals. Portals allow a component to render a sub component but to have it act as a child of some other component, usually the 'root' div. In this example StreamDelete is opening a modal window under 'root'. Portals are described in detail in the Udemy course Modern React with Redux section 21. When you attach the modal to a div the modal will replace the content of that div or whatever with the content of your modal. So you will almost always create a sibling to the 'root' element to attach the modal to. <body> <noscript>You need to enable JavaScript to run this app.</noscript> <div id=\"root\"></div> <div id=\"modal\"></div> </body> The modal component will not return normal jsx it will return the ReactDOM.createPortal function. import React from \"react\"; import ReactDOM from \"react-dom\"; const Modal = props => { return ReactDOM.createPortal( <div className=\"ui dimmer modals visible active\"> <div className=\"ui standard modal visible active\"> lorem20 crap lkjsflj ljsdf ljf lkjs flksjdf </div> </div>, document.querySelector(\"#modal\") ); }; export default Modal; To call the modal you just call it like any component import React from \"react\"; import Modal from \"../Modal\"; const StreamDelete = () => { return ( <div> StreamDelete <Modal /> </div> ); }; export default StreamDelete; NOTE: You would normally use Portals to render modal windows but would also use portals if trying to render some React component into some html that was not created by your application like server side rendered html like Java or Ruby or something like that.","title":"Modal window in a React app"},{"location":"React/Render-Props/","text":"Render Props The term \u201crender prop\u201d refers to a technique for sharing code between React components using a prop whose value is a function. It helps to share state or behavior that one component contains into another component. In most cases this technique can be handled cleaner with the new React Hooks. Hooks can replace some render props, but not all of them. Hooks can\u2019t render anything, they can\u2019t set values on context (even though they can consume values), and they can\u2019t implement error boundaries. Given these limitations, you may still find yourself using render props from time to time. React Docs Example In this example taken from the reactjs.org docs render props page you can see how they have made the Mouse component reusable by passing in a component to dynamically determine what to render. class Cat extends React.Component { render() { const mouse = this.props.mouse; return ( <img src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /> ); } } class Mouse extends React.Component { constructor(props) { super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = { x: 0, y: 0 }; } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}> {/* Instead of providing a static representation of what <Mouse> renders, use the `render` prop to dynamically determine what to render. */} {this.props.render(this.state)} </div> ); } } class MouseTracker extends React.Component { render() { return ( <div> <h1>Move the mouse around!</h1> <Mouse render={mouse => ( <Cat mouse={mouse} /> )}/> </div> ); } }","title":"Render Props"},{"location":"React/Render-Props/#render-props","text":"The term \u201crender prop\u201d refers to a technique for sharing code between React components using a prop whose value is a function. It helps to share state or behavior that one component contains into another component. In most cases this technique can be handled cleaner with the new React Hooks. Hooks can replace some render props, but not all of them. Hooks can\u2019t render anything, they can\u2019t set values on context (even though they can consume values), and they can\u2019t implement error boundaries. Given these limitations, you may still find yourself using render props from time to time.","title":"Render Props"},{"location":"React/Render-Props/#react-docs-example","text":"In this example taken from the reactjs.org docs render props page you can see how they have made the Mouse component reusable by passing in a component to dynamically determine what to render. class Cat extends React.Component { render() { const mouse = this.props.mouse; return ( <img src=\"/cat.jpg\" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} /> ); } } class Mouse extends React.Component { constructor(props) { super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = { x: 0, y: 0 }; } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( <div style={{ height: '100%' }} onMouseMove={this.handleMouseMove}> {/* Instead of providing a static representation of what <Mouse> renders, use the `render` prop to dynamically determine what to render. */} {this.props.render(this.state)} </div> ); } } class MouseTracker extends React.Component { render() { return ( <div> <h1>Move the mouse around!</h1> <Mouse render={mouse => ( <Cat mouse={mouse} /> )}/> </div> ); } }","title":"React Docs Example"}]}