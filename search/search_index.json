{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Test link to an image end of image test","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#test-link-to-an-image","text":"","title":"Test link to an image"},{"location":"#end-of-image-test","text":"","title":"end of image test"},{"location":"Dates and Times/","text":"Dates and Times Here's a thing: Should check out the Moment library https://momentjs.com/","title":"Dates and Times"},{"location":"Dates and Times/#dates-and-times","text":"Here's a thing: Should check out the Moment library https://momentjs.com/","title":"Dates and Times"},{"location":"ReactRouter/","text":"React Router Programmatic Navigation //programmatic navigation back to the root route // sometimes a little tricky import history from \"../history\"; history.push(\"/\"); // import createHistory from \"history/createBrowserHistory\"; const createHistory = require(\"history\").createBrowserHistory; export default createHistory(); Switch React Router will, by default, route 'greedily' That just means that if multiple routes match it will try to go to both routes. As in this it would go to streams/new and to streams/:id when you just want /streams/new <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> To stop this behavior and have it stop after the first hit you need to add the Switch component from react router dom as... import { Router, Route, Switch } from \"react-router-dom\"; <Switch> <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> </Switch>","title":"React Router"},{"location":"ReactRouter/#react-router","text":"","title":"React Router"},{"location":"ReactRouter/#programmatic-navigation","text":"//programmatic navigation back to the root route // sometimes a little tricky import history from \"../history\"; history.push(\"/\"); // import createHistory from \"history/createBrowserHistory\"; const createHistory = require(\"history\").createBrowserHistory; export default createHistory();","title":"Programmatic Navigation"},{"location":"ReactRouter/#switch","text":"React Router will, by default, route 'greedily' That just means that if multiple routes match it will try to go to both routes. As in this it would go to streams/new and to streams/:id when you just want /streams/new <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> To stop this behavior and have it stop after the first hit you need to add the Switch component from react router dom as... import { Router, Route, Switch } from \"react-router-dom\"; <Switch> <Route path=\"/\" exact component={StreamList} /> <Route path=\"/streams/new\" exact component={StreamCreate} /> <Route path=\"/streams/edit/:id\" exact component={StreamEdit} /> <Route path=\"/streams/delete/:id\" exact component={StreamDelete} /> <Route path=\"/streams/:id\" exact component={StreamShow} /> </Switch>","title":"Switch"},{"location":"TyporaTest/","text":"Typora that is a huge margin. kljfljfljsldfkjsdlf lskjdfls lskjd fl lskdjf l lkjsdf ll lksdjf lll sdflkl lskdjf ll sdlfkj llsjd fllksjdf llksdjf lskdjf lksdjf llskdj flslskdjf lslskjd fpwuerp wriu wsdjf lsz,mnvcnv ,xnv ,xc There must be a better way to insert images! This is a quick bit of code: class GoogleAuth extends React.Component { componentDidMount() { window.gapi.load(\"client:auth2\", () => { window.gapi.client .init({ clientId: \"318802615607-3l2k61n5spk3n7u6b2mb49geeqi2ueng.apps.googleusercontent.com\", scope: \"email\" }) .then(() => { this.auth = window.gapi.auth2.getAuthInstance(); this.onAuthChange(this.auth.isSignedIn.get()); this.auth.isSignedIn.listen(this.onAuthChange); }); }); } Have some tasks to do... [ ] do this [x] and this [ ] not this Now what ?","title":"TyporaTest"},{"location":"TyporaTest/#there-must-be-a-better-way-to-insert-images","text":"This is a quick bit of code: class GoogleAuth extends React.Component { componentDidMount() { window.gapi.load(\"client:auth2\", () => { window.gapi.client .init({ clientId: \"318802615607-3l2k61n5spk3n7u6b2mb49geeqi2ueng.apps.googleusercontent.com\", scope: \"email\" }) .then(() => { this.auth = window.gapi.auth2.getAuthInstance(); this.onAuthChange(this.auth.isSignedIn.get()); this.auth.isSignedIn.listen(this.onAuthChange); }); }); } Have some tasks to do... [ ] do this [x] and this [ ] not this Now what ?","title":"There must be a better way to insert images!"},{"location":"React/Hooks/","text":"Hooks Why Hooks Hooks overcomes many of the issues that we come across when using class based components. Calling Super(props) is annoying Classes make knowing how 'this' works difficult at times Organizing components by life-cycle methods forces us to sprinkle related logic throughout our components. React has no good primitive for sharing non-visual logic. Just use Functions Using functions instead of classes removes the Super(props) and 'this' issues right away. Ok great now what about state and life-cycle methods, they are kind of handy. State No need for a class based component. You will need to import 'useState' into your functional component. import React, { useState } from 'react' const Shop = props => { const [cart, setCart] = useState([]) const cartHandler = () => { setCart(['A Book']) } return <button onClick={cartHandler}>Add to Cart</button> } useState() returns an array with two elements. The first element is the state and the second is a function that will set the state. State is not just one object containing everything. You can have several 'states' and they can be anything like a string or boolean, whatever. It does not have to be an array as shown above. If you have multiple pieces if state that you need to track just create them like this... const [cart, setCart] = useState([]) const [myList, setMyList] = useState('not an array') When you set state it will completely replace state. You don't just pass in updates as you did in a class based component. So if your state was set to {el1: 'one', el2: 'two'} you could not just do setState({el2: 'three'}) you would have to either do setState({...state}, {el2: 'three'}) or something similar. Lifecycle Methods It looks like lifecycle Methods are sort of being referred to as 'side effects' under React Hooks. The core React Hook that will be used in place of the Lifecycle Methods is called useEffect(). componentDidMount To perform the functionality of the class based componentDidMount do the following import React, { useState, useEffect } from 'react' const Shop = props => { const [products, setProducts] = useState([]) useEffect(() => { fetch('my-backend.com/products') .then(res => res.json()) .then(fetchedProducts => setProducts(fetchedProducts)) }, []) return ( <ul> {products.map(product => ( <li key={product.id}>{product.name}</li> ))} </ul> ) } The key here is the second element of the useEffect function, the empty array []. The second element controls when this function gets run. It will run whenever the second element changes.","title":"Hooks"},{"location":"React/Hooks/#hooks","text":"","title":"Hooks"},{"location":"React/Hooks/#why-hooks","text":"Hooks overcomes many of the issues that we come across when using class based components. Calling Super(props) is annoying Classes make knowing how 'this' works difficult at times Organizing components by life-cycle methods forces us to sprinkle related logic throughout our components. React has no good primitive for sharing non-visual logic.","title":"Why Hooks"},{"location":"React/Hooks/#just-use-functions","text":"Using functions instead of classes removes the Super(props) and 'this' issues right away. Ok great now what about state and life-cycle methods, they are kind of handy.","title":"Just use Functions"},{"location":"React/Hooks/#state","text":"No need for a class based component. You will need to import 'useState' into your functional component. import React, { useState } from 'react' const Shop = props => { const [cart, setCart] = useState([]) const cartHandler = () => { setCart(['A Book']) } return <button onClick={cartHandler}>Add to Cart</button> } useState() returns an array with two elements. The first element is the state and the second is a function that will set the state. State is not just one object containing everything. You can have several 'states' and they can be anything like a string or boolean, whatever. It does not have to be an array as shown above. If you have multiple pieces if state that you need to track just create them like this... const [cart, setCart] = useState([]) const [myList, setMyList] = useState('not an array') When you set state it will completely replace state. You don't just pass in updates as you did in a class based component. So if your state was set to {el1: 'one', el2: 'two'} you could not just do setState({el2: 'three'}) you would have to either do setState({...state}, {el2: 'three'}) or something similar.","title":"State"},{"location":"React/Hooks/#lifecycle-methods","text":"It looks like lifecycle Methods are sort of being referred to as 'side effects' under React Hooks. The core React Hook that will be used in place of the Lifecycle Methods is called useEffect().","title":"Lifecycle Methods"},{"location":"React/Hooks/#componentdidmount","text":"To perform the functionality of the class based componentDidMount do the following import React, { useState, useEffect } from 'react' const Shop = props => { const [products, setProducts] = useState([]) useEffect(() => { fetch('my-backend.com/products') .then(res => res.json()) .then(fetchedProducts => setProducts(fetchedProducts)) }, []) return ( <ul> {products.map(product => ( <li key={product.id}>{product.name}</li> ))} </ul> ) } The key here is the second element of the useEffect function, the empty array []. The second element controls when this function gets run. It will run whenever the second element changes.","title":"componentDidMount"},{"location":"React/Portals/","text":"Modal window in a React app The key to getting a modal window to work in React is to use Portals. Portals allow a component to render a sub component but to have it act as a child of some other component, usually the 'root' div. In this example StreamDelete is opening a modal window under 'root'. Portals are described in detail in the Udemy course Modern React with Redux section 21. When you attach the modal to a div the modal will replace the content of that div or whatever with the content of your modal. So you will almost always create a sibling to the 'root' element to attach the modal to. <body> <noscript>You need to enable JavaScript to run this app.</noscript> <div id=\"root\"></div> <div id=\"modal\"></div> </body> The modal component will not return normal jsx it will return the ReactDOM.createPortal function. import React from \"react\"; import ReactDOM from \"react-dom\"; const Modal = props => { return ReactDOM.createPortal( <div className=\"ui dimmer modals visible active\"> <div className=\"ui standard modal visible active\"> lorem20 crap lkjsflj ljsdf ljf lkjs flksjdf </div> </div>, document.querySelector(\"#modal\") ); }; export default Modal; To call the modal you just call it like any component import React from \"react\"; import Modal from \"../Modal\"; const StreamDelete = () => { return ( <div> StreamDelete <Modal /> </div> ); }; export default StreamDelete; NOTE: You would normally use Portals to render modal windows but would also use portals if trying to render some React component into some html that was not created by your application like server side rendered html like Java or Ruby or something like that.","title":"Portals"},{"location":"React/Portals/#modal-window-in-a-react-app","text":"The key to getting a modal window to work in React is to use Portals. Portals allow a component to render a sub component but to have it act as a child of some other component, usually the 'root' div. In this example StreamDelete is opening a modal window under 'root'. Portals are described in detail in the Udemy course Modern React with Redux section 21. When you attach the modal to a div the modal will replace the content of that div or whatever with the content of your modal. So you will almost always create a sibling to the 'root' element to attach the modal to. <body> <noscript>You need to enable JavaScript to run this app.</noscript> <div id=\"root\"></div> <div id=\"modal\"></div> </body> The modal component will not return normal jsx it will return the ReactDOM.createPortal function. import React from \"react\"; import ReactDOM from \"react-dom\"; const Modal = props => { return ReactDOM.createPortal( <div className=\"ui dimmer modals visible active\"> <div className=\"ui standard modal visible active\"> lorem20 crap lkjsflj ljsdf ljf lkjs flksjdf </div> </div>, document.querySelector(\"#modal\") ); }; export default Modal; To call the modal you just call it like any component import React from \"react\"; import Modal from \"../Modal\"; const StreamDelete = () => { return ( <div> StreamDelete <Modal /> </div> ); }; export default StreamDelete; NOTE: You would normally use Portals to render modal windows but would also use portals if trying to render some React component into some html that was not created by your application like server side rendered html like Java or Ruby or something like that.","title":"Modal window in a React app"}]}